resources:
  pipelines:
  - pipeline: parent  #string reference you will use in this yaml file
    source: parent-build #name of the source pipeline
    trigger: true

  repositories:
  - repository: tools
    type: git
    name: Tools

variables:
- group: <NAME OF THE MICROSERVICE>-deploy
- group: k8s-deploy

trigger: none

pool:
  vmImage: 'ubuntu-latest' # set to windows-latest or another Windows vmImage for Windows builds

steps:
- checkout: tools

- task: DownloadBuildArtifacts@0
  displayName: 'Download variables'
  inputs:
    buildType: 'specific'
    project: '<YOUR AZURE DEVOPS PROJECT ID>'
    pipeline: '<PARENT PIPELINE DEFINITION ID>'
    buildVersionToDownload: 'latest'
    downloadType: 'specific'
    downloadPath: '$(System.ArtifactsDirectory)'

- task: Powershell@2
  displayName: Ingest variables from build pipeline
  inputs:
    targetType: inline
    script: |
      $content = Get-Content  $env:SYSTEM_ARTIFACTSDIRECTORY/variables/pipeline.env
      foreach($line in $content) {
        $key=$line.split("=")[0]
        $value=$line.split("=")[1]
        Write-Host "##vso[task.setvariable variable=$key]$value"
        Write-Verbose "Creating new variable $key with value $value" -vb
      }

- task: Powershell@2
  displayName: Read ENV vars
  inputs:
    targetType: inline
    script: |
      gci env:

- task: Powershell@2
  displayName: Prepare deployment
  inputs:
    targetType: inline
    script: |

      #check that the files from the Tools repo are here
      gci | select name, fullname

      #compose necessary variables
      $env:FULLIMAGENAME = "shikki/<NAME OF THE MICROSERVICE>:" + $env:IMAGE_TAG
      $path2Manifest = gci | where {$_.name -eq "kubernetes_manifest.yaml"} | select -expand fullname
      $path2Script = gci | where {$_.name -eq "Set-TokenValues.ps1"} | select -expand fullname

      Write-Output "======= Variable values ======="
      $env:FULLIMAGENAME
      $path2Manifest
      $path2Script

      #replace tokens in manifest
      Write-Output "======= Replacing tokens in the manifest ======="
      Invoke-Expression "$path2Script -inputFilePath $path2Manifest"

      #let's read the manifest too
      Write-Output "======= Manifest content ======="
      Get-Content $path2Manifest
  env:
    SPRING_DATASOURCE_PASSWORD: $(SPRING_DATASOURCE_PASSWORD)
    SPRING_DATASOURCE_USERNAME: $(SPRING_DATASOURCE_USERNAME)
      
- task: AzureCLI@2
  displayName: deploy to AKS
  inputs:
    azureSubscription: <NAME OF YOUR AZURE RESOURCE MANAGER SERVICE CONNECTION>
    scriptType: pscore
    scriptLocation: inlineScript
    inlineScript: |

      #get aks credentials
      az aks get-credentials -n $env:CLUSTER_NAME -g $env:CLUSTER_RG --admin
      $path2Manifest = gci | where {$_.name -eq "kubernetes_manifest.yaml"} | select -expand fullname

      #check if kubernetes namespace exists and create if not
      kubectl create namespace $env:DEPLOYMENT_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

      #actual deploy
      kubectl apply -f $path2Manifest --namespace $env:DEPLOYMENT_NAMESPACE